# Stash

No rules. Just stuff.

---

Kaizen. Continuous Improvement.

## TL;DR

- **Set clear goals:** identify a long-term vision for you
- **Set short-term goals:** break your horizon goal into achievable milestones and adjust them as you grow
- **Fundamentals:** deepen your understanding of data structures, algorithms, and system design (building blocks)
- **Build projects:** choose a project that excites you focus on completing it to gain practical experience
- **Contribute to open-source:** engage with the community, which will enhance your skills and network
- **Experiment and innovate:** approach problems with curiosity and a willingness to experiment
- **Avoid analysis paralysis:** break tasks into smaller, manageable steps and set deadlines to maintain momentum
- **Document your progress, challenges, and achievements:** reflect regularly to identify areas for improvement

## Learn by doing

- Be hands-on (solidifies understaning)
  - Every challenge faced and every bug solved adds to your skill set
- Start simple/small (grasp core concepts quickly)
- Gradually increase complexity
- Focus on building real projects
- Set small, achievable goals
- Break larger projects into manageable tasks

<mark><h2>Hacker mindset</h2></mark>

- Take immediate action
- Embrace curiosity and constantly question how things work
  - Great developers are driven by a desire to explore and understand
  - This curiosity leads to constant tinkering, experimenting, and learning
- Develop a willingness to experiment and take risks
- Practice reverse engineering to understand complex systems
- Adaptability
  - The ability to adapt and apply knowledge to new scenarios
  - Understanding the underlying principles and being able to reshape and repurpose them as needed

Examples:

- [ ] Launch a personal project this week (an idea that excites you)
- [ ] Choose an open-source project and fix a small bug or add a minor feature
- [ ] Reverse engineer an application
  - [ ] Choose a simple application or device
  - [ ] Document your process and share findings online

## Consistency

- Dedicate a small amount of time each day
- Regular practice is more important than duration
- Read technical books, blogs, and research papers (implement examples as you read)
- Seek feedback from more experienced developers

## Fundamentals

- Focus on understanding core concepts
- Focus on foundational knowledge that is transferable across different areas
- Dive into the low-level of things to gain deeper understanding of how they work

Examples:

- [ ] Fundamental concepts
  - [ ] Abstraction
  - [ ] Modularity
  - [ ] Algorithms
  - [ ] Data structures
  - [ ] Testing
  - [ ] Debugging
  - [ ] Problem-solving
  - [ ] Design patterns
- [ ] Operating systems and computer architecture
- [ ] Computer networking and distributed systems

## Embrace challenges

- View debugging as a learning opportunity
- Troubleshooting issues helps deepen your understanding of how things work
- Push yourself by working on ambitious projects
  - Choose an area that pushes your limits
  - Set aggressive milestones and stick to them
- Contribute to open-source projects (gain experience, learn from others)
  - Find projects aligned with your interests on GitHub
  - Start with small contributions, then tackle larger features
- Participate in hackathons and coding competitions

## Interest-driven learning

- Explore different areas to find what interests you most
- Focus on areas that genuinely excite you

## Track and reflect

- Document your daily progress, challenges, and breakthroughs
- Review weekly to identify areas for improvement
- Set ambitious but achievable goals
  - Create 30-day, 90-day, and 1-year goals for your skills development
  - Regularly assess and adjust your goals based on progress
 
---

## Books

- [ ] Computer Organization and Design: The Hardware/Software Interface by David A. Patterson and John L. Hennessy.
- [ ] Computer Architecture: A Quantitative Approach by John L. Hennessy and David A. Patterson.
- [ ] Parallel Computer Architecture: A Hardware/Software Approach by David Culler and Jaswinder Pal Singh.
- [ ] Operating System Concepts by Abraham Silberschatz, Peter B. Galvin, and Greg Gagne.
- [ ] Modern Operating Systems by Andrew S. Tanenbaum and Herbert Bos.
- [ ] The Design of the UNIX Operating System by Maurice J. Bach.
- [ ] Computer Networking: A Top-Down Approach by James F. Kurose and Keith W. Ross.
- [ ] TCP/IP Illustrated by W. Richard Stevens.
- [ ] Programming from the Ground Up by Jonathan Bartlett.
- [ ] Designing Data-Intensive Applications by Martin Kleppmann.
- [ ] System Design Interview by Alex Xu.
- [ ] The Art of Debugging with GDB, DDD, and Eclipse by Norman Matloff and Peter Jay Salzman.
- [ ] Database System Concepts by Abraham Silberschatz, Henry F. Korth, and S. Sudarshan.
- [ ] Site Reliability Engineering by Niall Richard Murphy, Betsy Beyer, Chris Jones, and Jennifer Petoff.
- [ ] The Pragmatic Programmer by Andrew Hunt and David Thomas.

## Courses

- [ ] Onur Mutlu's courses on YouTube: Design of Digital Circuits and Computer Architecture.
- [ ] David Wentzlaff's Coursera Computer Architecture Course.
- [ ] MIT's [Operating System Engineering](https://ocw.mit.edu/courses/6-828-operating-system-engineering-fall-2012/).
- [ ] Stanford's [Computer and Network Security](https://online.stanford.edu/courses/cs155-computer-and-network-security).
- [ ] [x86 Assembly Language Programming](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html).
- [ ] Stanford's Databases.
- [ ] Google Cloud's SRE course.
- [ ] 
