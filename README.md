# Stash

No rules. Just stuff.

- The internet has revolutionized access to knowledge, everyone can learn and share information globally
- The internet is a catalyst for innovation
- Personal data is at risk of surveillance and data exploitation
- Misinformation can be spread too easily on digital platforms
- What the internet should be like:
  - **Decentralized:** users have more control over their data and online interactions (counters the dominance of large tech companies, enhances privacy)
  - **Open access:** open access to information and technology, minimal barriers to entry foster innovation and creativity
  - **User empowerment:** empower users with tools that allow them to manage their online presence effectively (better privacy controls, transparency regarding data usage)
  - **Resilience:** the internet should be robust enough to continue functioning despite failures or attacks
- What the web should be like:
  - **Simple designs:** websites are filled with JavaScript frameworks and unnecessary features, making them harder to navigate and less user-friendly; the goal is simplicity in web design, a good website should be clean, easy to read, and straightforward to navigate
  - **Ad-less:** ad-based revenue models lead to cluttered interfaces and intrusive pop-ups, detracting from the experience
  - **Decentralized:** the internet should not be dominated by a few large corporations; it should allow individuals to host their own content and services without central control or censorship
  - **Open access:** information should be freely accessible to everyone (barriers to accessing knowledge hinder innovation and personal growth)
  - **Privacy and security:** users should have robust privacy protections, ensuring that their data is not exploited by corporations or governments (transparent policies regarding data collection and usage)
  - **Empowerment through technology:** users should be equipped with tools that enhance their online experiences without overwhelming them with complexity (intuitive interfaces, responsive designs that adapt to users' needs)
  - **Support for innovation:** the internet should foster an environment where new ideas can flourish without excessive regulation or gatekeeping by powerful entities

---

Kaizen. Continuous Improvement.

## TL;DR

- **Set clear goals:** identify a long-term vision for you
- **Set short-term goals:** break your horizon goal into achievable milestones and adjust them as you grow
- **Fundamentals:** deepen your understanding of data structures, algorithms, and system design (building blocks)
- **Build projects:** choose a project that excites you focus on completing it to gain practical experience
- **Contribute to open-source:** engage with the community, which will enhance your skills and network
- **Experiment and innovate:** approach problems with curiosity and a willingness to experiment
- **Avoid analysis paralysis:** break tasks into smaller, manageable steps and set deadlines to maintain momentum
- **Document your progress, challenges, and achievements:** reflect regularly to identify areas for improvement

## Learn by doing

- Be hands-on (solidifies understaning)
  - Every challenge faced and every bug solved adds to your skill set
- Start simple/small (grasp core concepts quickly)
- Gradually increase complexity
- Focus on building real projects
- Set small, achievable goals
- Break larger projects into manageable tasks

<mark><h2>Hacker mindset</h2></mark>

- Take immediate action
- Embrace curiosity and constantly question how things work
  - Great developers are driven by a desire to explore and understand
  - This curiosity leads to constant tinkering, experimenting, and learning
- Develop a willingness to experiment and take risks
- Practice reverse engineering to understand complex systems
- Adaptability
  - The ability to adapt and apply knowledge to new scenarios
  - Understanding the underlying principles and being able to reshape and repurpose them as needed

Examples:

- [ ] Launch a personal project this week (an idea that excites you)
- [ ] Choose an open-source project and fix a small bug or add a minor feature
- [ ] Reverse engineer an application
  - [ ] Choose a simple application or device
  - [ ] Document your process and share findings online

## Consistency

- Dedicate a small amount of time each day
- Regular practice is more important than duration
- Read technical books, blogs, and research papers (implement examples as you read)
- Seek feedback from more experienced developers

## Fundamentals

- Focus on understanding core concepts
- Focus on foundational knowledge that is transferable across different areas
- Dive into the low-level of things to gain deeper understanding of how they work

Examples:

- [ ] Fundamental concepts
  - [ ] Abstraction
  - [ ] Modularity
  - [ ] Algorithms
  - [ ] Data structures
  - [ ] Testing
  - [ ] Debugging
  - [ ] Problem-solving
  - [ ] Design patterns
- [ ] Operating systems and computer architecture
- [ ] Computer networking and distributed systems

## Embrace challenges

- View debugging as a learning opportunity
- Troubleshooting issues helps deepen your understanding of how things work
- Push yourself by working on ambitious projects
  - Choose an area that pushes your limits
  - Set aggressive milestones and stick to them
- Contribute to open-source projects (gain experience, learn from others)
  - Find projects aligned with your interests on GitHub
  - Start with small contributions, then tackle larger features
- Participate in hackathons and coding competitions

## Interest-driven learning

- Explore different areas to find what interests you most
- Focus on areas that genuinely excite you

## Track and reflect

- Document your daily progress, challenges, and breakthroughs
- Review weekly to identify areas for improvement
- Set ambitious but achievable goals
  - Create 30-day, 90-day, and 1-year goals for your skills development
  - Regularly assess and adjust your goals based on progress
 
---

## Books

- [ ] Computer Organization and Design: The Hardware/Software Interface by David A. Patterson and John L. Hennessy.
- [ ] Computer Architecture: A Quantitative Approach by John L. Hennessy and David A. Patterson.
- [ ] Parallel Computer Architecture: A Hardware/Software Approach by David Culler and Jaswinder Pal Singh.
- [ ] Operating System Concepts by Abraham Silberschatz, Peter B. Galvin, and Greg Gagne.
- [ ] Modern Operating Systems by Andrew S. Tanenbaum and Herbert Bos.
- [ ] The Design of the UNIX Operating System by Maurice J. Bach.
- [ ] Computer Networking: A Top-Down Approach by James F. Kurose and Keith W. Ross.
- [ ] TCP/IP Illustrated by W. Richard Stevens.
- [ ] Programming from the Ground Up by Jonathan Bartlett.
- [ ] Designing Data-Intensive Applications by Martin Kleppmann.
- [ ] System Design Interview by Alex Xu.
- [ ] The Art of Debugging with GDB, DDD, and Eclipse by Norman Matloff and Peter Jay Salzman.
- [ ] Database System Concepts by Abraham Silberschatz, Henry F. Korth, and S. Sudarshan.
- [ ] Site Reliability Engineering by Niall Richard Murphy, Betsy Beyer, Chris Jones, and Jennifer Petoff.
- [ ] The Pragmatic Programmer by Andrew Hunt and David Thomas.

- [ ] Computer Systems: A Programmer's Perspective (CS:APP)
- [ ] Computer Architecture" by Charles Fox (No Starch Press)
- [ ] Dive Into Systems by Suzanne J. Matthews, Tia Newhall, and Kevin C. Webb (No Starch Press)

## Courses

- [ ] Onur Mutlu's courses on YouTube: Design of Digital Circuits and Computer Architecture.
- [ ] David Wentzlaff's Coursera Computer Architecture Course.
- [ ] MIT's [Operating System Engineering](https://ocw.mit.edu/courses/6-828-operating-system-engineering-fall-2012/).
- [ ] Stanford's [Computer and Network Security](https://online.stanford.edu/courses/cs155-computer-and-network-security).
- [ ] [x86 Assembly Language Programming](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html).
- [ ] Stanford's Databases.
- [ ] Google Cloud's SRE course.
- [ ] 

---

## Learning sequence

- Computer Organization and Architecture
- C Programming
- Assembly Language
- Operating Systems
- Computer Networking
- Golang
- Databases
- System Design and Architecture
- Debugging and Performance Optimization
- Infrastructure and DevOps
- Cybersecurity

---

## Ideas

- [ ] Operating System
  - [ ] Study computer architecture and assembly language
  - [ ] Implement a bootloader
  - [ ] Develop a basic kernel
  - [ ] Add memory management
  - [ ] Implement process scheduling
  - [ ] Create a simple file system
  - [ ] Add basic device drivers
  - [ ] Resources
    - [ ] Operating Systems: Three Easy Pieces by Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau
    - [ ] https://wiki.osdev.org/Expanded_Main_Page
    - [ ] https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System
- [ ] Network Protocol
  - [ ] Study network protocols and TCP/IP stack
  - [ ] Implement the IP layer
  - [ ] Develop the TCP layer
  - [ ] Create a simple application layer protocol
  - [ ] Test your implementation using network simulation tools
  - [ ] Resources
    - [ ] TCP/IP Illustrated, Volume 1: The Protocols by W. Richard Stevens
    - [ ] https://beej.us/guide/bgnet/
- [ ] Database Management System
  - [ ] Design the storage engine
  - [ ] Implement basic SQL parsing
  - [ ] Develop query execution engine
  - [ ] Add indexing capabilities
  - [ ] Implement transaction management
  - [ ] Create a simple client interface
  - [ ] Resources
    - [ ] Database System Concepts by Abraham Silberschatz, Henry F. Korth, and S. Sudarshan
    - [ ] https://15445.courses.cs.cmu.edu/fall2024/
    - [ ] https://cstack.github.io/db_tutorial/
- [ ] Compiler
  - [ ] Implement a lexical analyzer
  - [ ] Create a parser for the grammar
  - [ ] Develop semantic analysis
  - [ ] Implement intermediate code generation
  - [ ] Add code optimization techniques
  - [ ] Generate target machine code
  - [ ] Resources
    - [ ] Compilers: Principles, Techniques, and Tools by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman
    - [ ] https://web.stanford.edu/class/cs143/
    - [ ] https://llvm.org/
- [ ] Distributed Key-value Store
  - [ ] Design the system architecture
  - [ ] Implement basic client-server communication
  - [ ] Add data replication and consistency mechanisms
  - [ ] Implement distributed consensus (e.g., Raft algorithm)
  - [ ] Add failure detection and recovery
  - [ ] Optimize for performance and scalability
  - [ ] Resources
    - [ ] Designing Data-Intensive Applications by Martin Kleppmann
    - [ ] https://pdos.csail.mit.edu/6.824/
    - [ ] https://raft.github.io/
- [ ] Machine Learning Framework
  - [ ] Implement fundamental ML algorithms (linear regression, logistic regression)
  - [ ] Add support for neural networks
  - [ ] Implement backpropagation and gradient descent
  - [ ] Add optimization algorithms (e.g., Adam, RMSprop)
  - [ ] Implement convolutional and recurrent layers
  - [ ] Create a simple API for model creation and training
  - [ ] Resources
    - [ ] Deep Learning by Ian Goodfellow, Yoshua Bengio, and Aaron Courville
    - [ ] https://course.fast.ai/
    - [ ] https://github.com/pytorch/pytorch
